## Context

After implementing multi-tenant Phases 1-3 (user auth, key encryption, env hydration, cron fan-out, per-user webhooks), a security audit found residual single-tenant patterns:
- Hardcoded worker URLs that should use `env.WORKER_URL` (set as Worker secret in Phase 2)
- DB functions that query by ID without verifying chat_id ownership
- A fragile `isAdmin()` fallback

The multi-tenant architecture is sound — `hydrateEnv` correctly overlays user keys and sets `TELEGRAM_CHAT_ID` to the user's chatId. The issues are all at the edges: individual queries and URL construction that were written before multi-tenancy.

## Goals / Non-Goals

**Goals:**
- Every DB query that accesses user-scoped data includes `chat_id` in the WHERE clause
- Every constructed URL uses `env.WORKER_URL` instead of hardcoded strings
- `isAdmin()` is robust regardless of env hydration state

**Non-Goals:**
- Changing the `hydrateEnv` pattern itself (it works correctly)
- Adding per-user rate limiting (separate concern)
- Adding audit logging for cross-tenant access attempts

## Decisions

### 1. Hardcoded URL replacement — simple string substitution

**Decision**: Replace all 9 instances of `https://content-bot.keisarcontentcreator.workers.dev` with `env.WORKER_URL`. For functions/views that don't receive `env` directly, thread it through from the caller.

**Rationale**: `WORKER_URL` is already in the Env type and configured as a secret. This is a direct find-and-replace with env threading where needed.

**Note**: `views/video-studio.ts` renders views that may not have direct access to env. Check if `env` is passed to the render function; if not, pass `WORKER_URL` as a parameter.

### 2. DB query hardening — add chat_id to WHERE clauses

**Decision**: Add `chatId` parameter to all 6 unguarded functions and include `AND chat_id = ?` (or equivalent ownership join) in the query. For functions called from external webhook contexts (HeyGen), use the `chat_id` from the fetched row itself when no session chatId is available.

Functions to update:
- `getScoredTweetsByBatchMessage(env, batchMessageId)` → add `chatId` param, add `AND chat_id = ?`
- `getRecentTweetsByAccount(env, accountId)` → add `chatId` param, join or sub-query through `twitter_accounts` to verify ownership
- `getTwitterAccountOverview(env, accountId)` → add `chatId` param, join through `twitter_accounts`
- `getTwitterTweet(env, tweetId)` → add `chatId` param, add `AND chat_id = ?`
- `getVideoDraftByHeygenId(env, heygenVideoId)` → keep as-is (external webhook, no session) but document that it's intentionally unscoped
- `getRepoOverview(env, repoId)` → add optional `chatId` param, join through `repos` when provided

**Rationale**: Defense-in-depth. Even though callers currently verify ownership, the DB layer should enforce it so a missed check in a future caller doesn't create a vulnerability.

**For `getRecentTweetsByAccount` and `getTwitterAccountOverview`**: These query by `account_id`, not directly by `chat_id`. The `twitter_tweets` table has `chat_id` (set when tweets are created by the poller). The `twitter_account_overviews` table does NOT have `chat_id` — it's keyed by `account_id`. For these, verify ownership of the account_id against `twitter_accounts.chat_id` before querying.

### 3. isAdmin hardening

**Decision**: Change `isAdmin()` to require `ADMIN_CHAT_ID` explicitly, not fall back to `TELEGRAM_CHAT_ID`. If `ADMIN_CHAT_ID` is not set, nobody is admin.

**Rationale**: After hydration, `TELEGRAM_CHAT_ID` is the user's chatId. Falling back to it would make the current user appear to be admin. `hydrateEnv` always sets `ADMIN_CHAT_ID`, but defensive code shouldn't rely on that.

## Risks / Trade-offs

**[Signature changes to DB functions]** → Callers need updating. All callers are internal and already have `chatId` in scope. Mechanical change.

**[getVideoDraftByHeygenId left unscoped]** → Intentional. HeyGen webhook is an external callback with no user session. The heygen_video_id is an opaque UUID generated by HeyGen, not enumerable. The handler uses `draft.chat_id` for notifications, so it's self-scoping.

**[Performance of ownership joins]** → Adding a JOIN or sub-query to verify account ownership adds negligible overhead (indexed columns, small tables).
